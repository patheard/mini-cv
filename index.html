<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="x-ua-compatible" content="ie=edge">
		
		<title>Pat Heard â€” Full stack web developer</title>
		
		<meta name="description" content="Mini CV of Pat Heard, but more importantly, a chance to play with Paper.js">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<link href="https://fonts.googleapis.com/css?family=Roboto%3A300%7CMuli%3A800" rel="stylesheet">
		<link href="css/main.css" rel="stylesheet">

		<link rel="icon" href="img/favicon.png">
	</head>
	<body>
			
		<div id="content">
		
			<header>
				<h1>Pat Heard</h1>
				<p>Full stack web developer with a special place in my heart for javascript.</p>
			</header>	
			
			<main>
				<h2>Experience</h2>
				<ul>
					<li>20 years of making things for the web.  Everything from small one-pagers to backend apps under heavy load.</li>
					<li>All manner of design.  From branding to mobile to interface with a healthy dose of UX mixed in for good measure.</li>
					<li>Working as part of a team or solo, to take an idea all the way from conception to launch.</li>				
				</ul>	

				<h2>Strengths</h2>
				<ul>
					<li>A desire to continuously improve.</li>
					<li>Ability to write code quickly, that works.</li>
					<li>The understanding that to succeed you must iterate and validate.</li>
				</ul>

				<h2>Weaknesses</h2>
				<ul>
					<li>Getting caught up in the details.</li>
					<li>Possibly overestimating what Docker can do.</li>
					<li>M&M's Peanuts and/or Almonds.  They're both problematic.</li>
				</ul>
			</main>

			<footer>
				<ul>
					<li><a href="mailto:pat.heard@gmail.com" class="font-muli">Say hi</a></li>
					<li><a href="http://fullahead.org" class="font-muli">Portfolio</a></li>
				</ul>			
			</footer>
			
		</div>	
		
		<canvas id="scene" data-paper-resize></canvas>
		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.11.4/paper-full.min.js" integrity="sha256-6JvCFx66pzkbqlMKQ+7bRGX7HIUlpEyF0iLXRP/bx1M=" crossorigin="anonymous"></script>   
		<script type="text/paperscript" data-paper-canvas="scene">
			/* globals paper, Color, Group, Path, Point */
			( function( window, project, view ){
				
			"use strict";
			
			/**
			 * Scene object responsible for creating the background and elements.  It also handles the animation
			 * resize and user scroll events.
			 */ 
			var Scene = {
				
				colors: {				// Colours to use for the shape transitions. TODO: dynamically set colours based on time of day.
					min: new Color( "blue" ),
					max: new Color( "purple" )
				},
				decelerationTime: 2000,	// Time that it takes for a shape to stop moving
				lastScroll: 0,			// Track the amount of the last user's scroll
				triangles: null,		// Group to hold the triangle elements
							
				/**
				 * Initalize the scene by placing the background and elements.  Element count and placement is dynamic
				 * and based on the size of the viewport.
				 */			
				init: function(){
					var shapeOffsetX = 50,												// Distance each shape is placed from its neighbour
						shapeRadius = view.bounds.height * 0.7,							// Radius of each shape (based on view height)
						shapeCount = Math.floor( view.bounds.width / shapeOffsetX ), 	// Number of shapes on the canvas (based on the total width of the view)
						shapePositionY = view.bounds.height - shapeRadius / 2,			// The y axis position of each shap (based on view height and shape radius)
						shapeTriangle = new Path.RegularPolygon({
							center: [ 0, 0 ],
							sides: 3,
							radius: shapeRadius,
							fillColor: Scene.colors.min,
							opacity: 0.1
						}),
						background = new Path.Rectangle({
							from: [ 0, 0 ],
							to: [ view.bounds.width, view.bounds.height ],
							fillColor: {
								gradient: {
									stops: ["#d3ecf5", "#6bbfde", "#2ea3ce"],
									radial: true
								},
								origin: [ view.center.x, 0 ],
								destination: [ view.center.x, view.bounds.height + 500 ]
							}					
						}),
						triangleMouseEnter = function( event ){
							this.data.animate = true;
							this.data.hueDelta = 1;
						},
						triangleMouseLeave = function( event ){
							this.data.animate = false;
							this.data.stopTimestamp = ( new Date() ).getTime() + Scene.decelerationTime;
							this.data.stopDelta = 1;
						};
					
					// Create and place the triangles elements
					Scene.triangles = new Group();
					for (var i = 0; i < shapeCount; i++) {
						var pointRandom = new Point( 0, 250 ) * Point.random(),
							triangle = shapeTriangle.clone();
						
						// Position the triangle and bind mouse event handlers.  Triangles are positioned from the center outwards, alternating from left to right.
						triangle.position = new Point( view.center.x + ( i % 2 ? -1 : 1 ) * shapeOffsetX * i, shapePositionY + pointRandom.y );					
						triangle
							.on( "mouseenter", triangleMouseEnter )					
							.on( "mouseleave", triangleMouseLeave );
						
						Scene.triangles.addChild( triangle );
					}

					// Reset the last scroll so that the triangles can be properly positioned with the window's existing scroll
					Scene.lastScroll = 0;
				},
				
				/**
				 * Animate the scene.  This is called by paper.js' onFrame event handler and is reponsible for repositioning
				 * elements in relation to how the user is interacting with the page.
				 * @param Event The paper.js Event object passed by the onFrame event handler.
				 */
				animate: function( event ){
					var eventTimestamp = ( new Date() ).getTime();
				
					// Loop through the triangles that have been placed on the active layer
					for ( var i = 0, len = Scene.triangles.children.length; i < len; i++ ) {
						var item = Scene.triangles.children[ i ];
			
						// Item is intersected by the mouse: animate its position
						if( item.data.animate ){
							item.position.y += Math.sin( event.time + i );
							item.fillColor.hue += 1 * item.data.hueDelta;
							
							// Check if the colour has cycled to the max or min colours and reverse cycle direction as needed.
							item.data.hueDelta = item.fillColor.hue > Scene.colors.max.hue ? -1 : item.fillColor.hue < Scene.colors.min.hue ? 1 : item.data.hueDelta;						
						
						// Item is no longer intersected, but it hasn't finished decelerating yet
						} else if( item.data.stopDelta > 0 ){										
							item.position.y += Math.sin( event.time + i ) * item.data.stopDelta / Scene.decelerationTime;
							item.data.stopDelta = item.data.stopTimestamp - eventTimestamp;
						}
					}
				},
			
				/**
				 * Redraw the scene when the browser is resized.  Does this by clearing all elements and re-drawing.
				 * @param Event The paper.js Event object passed by the onFrame event handler.
				 */
				resize: function( event ){
					project.clear();
					Scene.init();
					Scene.scroll();
				},
				
				/**
				 * Handle user scroll events.  Moves the elements in the scene relative to the amount the user has scrolled the window.
				 */
				scroll: function(){
					var triangle,
						scrollTop = window.pageYOffset,
						scrollDelta = scrollTop - Scene.lastScroll;
				
					// Change the triangle position in relation to how much the user has scrolled.  
					for ( var i = 0, len = Scene.triangles.children.length; i < len; i++ ) {
						triangle = Scene.triangles.children[ i ];
						triangle.position.y += ( i * scrollDelta ) / 10;						
					}
					
					// Track the current scrollTop so that we can calculate the scoll delta when the event fires again
					Scene.lastScroll = scrollTop;
				}
			};
			
			// Make the magic happen
			Scene.init();
			
			// View animation and resize event handlers
			view
				.on( "frame", Scene.animate )
				.on( "resize", Scene.resize );
			
			// Smoothly scroll the triangles as the user scrolls
			window.onscroll = Scene.scroll;
			
			// Make the scene object globally available
			window.scene = Scene;
			
			}( window, paper.project, paper.view ) );			
		</script>
	</body>
</html>
